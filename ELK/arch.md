#### Архитектура и всякое

##### назначение нод
##### жизненый цикл данных
##### масштабирование 
##### пример для ОС

###### назначение нод
```

Потребеление по ресурсам 
^^    очень высокая 
^     высокая
->    среднее
<-    низкое
```

|NODA        | DISK | RAM | CPU | NET |
|:----------:|:----:|:---:|:---:|:----|
|master      | <-   | ^   | ^   | ^   |
|data        | ^^   | ^   | ^   | ->  |
|ingest      | <-   |->   | ^   | ->  |
|ML          | <-   | ^^  | ^^  | ->  |
|coordinator | <-   | ->  | ->  | ->  |

###### жизненый цикл данных

|DATA   |   node    |  (RAM/disk)  |
|------:|:---------:|:-------------|
|hot    |   SSD     |   1/30       |
|warm   |   hdd     |   1/100      |
|could  |   hdd     |   1/500      |

```
Потребление ресурсов при операциях  

index - обработка и сохранение документов в индексе 

client --PUT--> Coordinator --> ingest node --> data node
                    NET            COMPUTE       NET COMPUTE DISK


client --DELETE--> Coordinator --> data node
                     NET             DISK    

UPDATE = PUT + DELETE

Search - GET

client --GET--> Coordinator --> data node
         NET        RAM       NET COMPUTE DISK

```
###### масштабирование 
```
1  V хранение (DISK RAM)
2  пропускная способность (CPU NET)

Как считать 
А1 - объем сырых данных RAW
A2 - период хранения
A3 - фактор трансформации данных = 1 в общем случае
A4 - кол-во щард репликации
A5 - объем памяти ноды
A6 - соотношении памяти к данным

Сжатие данных LZ4, DEFLATE на 15% лучше

BEST PRACTICE + 15% - запас по DISK
              + 5%  - ресурсов на доп. нужнды
              + 1 нода с данными


V1 объем данных в промежуток времени (день\неделя\ итд)

V1 = A1 * A2 * A3 * (A4 -1) 

V2 хранимый объем данных

V2 = A1 * (1+ 0,15 + 0,05)

15% - запас по DISK
5%  - ресурсов на доп. нужнды

Кол-во нод N округляем в большую сторону по принципу 1.2 будет 2

N = V2/V(памяти ноды)/Vc соотношение памяти к данным  + 1 (нода в запасе)

N = (V2/V/Vc)+1

Расчет кол-ва шардов и нод данных в зависимости от V храниения

В1 - кол-во index patterns
В2 - кол-во основных шард и реплик
В3 - время ротации index дней
В4 - время хранения index дней
В5 - V объем памяти на каждую ноду

не более 20 shard на 1GB JVM heap (на каждую ноду)
не более 40 GB на 1 shard

Кол-во шардов = В1 * В2 основных * (В2 реплик +1 ) * В4
Кол-во нод данных = округляем вверх (Кол-во шардов/20*В5)

расчет в зависимости от пропускной способности (надо увеличить при частых и в большом кол-ве поисковых запросов)

С1 - пиквое число поисковых запросов
С2 - среднее допустимое время ответов в милисекундах 
С3 ядер и thread на дата ноду

Пиковое значение тредов = Округляем ввверх (С1 * С2/1000 милисекунд)

С4 обем thread hod = Округляем вверх ((физ ядро *С3 * 3/2)+ 1)

Кол-во нод данных = Округляем вверх С1/С4
```

|         | Прирост данных | V disk | active shard | all shard | CORE/RAM |
|:--------|:--------------:|:------:|:------------:|:---------:|:---------|      
| xmall   |   0 - 10 GB    | 200 GB |       4      |    300    |   2/16   |
| small   |   10 - 100 GB  |  2 TB  |       8      |    600    |   2/16   |
| medium  |   100 - 500 GB |  9 TB  |       30     |    3000   |   8/64   |
| large   |   0.5 - 1 TB   |  16 TB |       60     |    3000   |   16/128 |
| xlarge  |   1 - 10 TB    | 180 TB |       600    |    5000   |   32/256 |

