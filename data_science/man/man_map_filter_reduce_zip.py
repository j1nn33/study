# Функцию mар используют с функциями нескольких аргументов, предоставляя ей
# несколько списков:
# перемножить аргументы

def multiply(x, y): 
    return x * y 
products = map(multiply, [1, 2], [4, 5]) 
# [1 * 4, 2 * 5] = [4, 10]

#Функция filter работает аналогично генератору последовательности с условием if:
# проверка четности
def is_even(x):
    """True, если x - четное; False, если x - нечетное"""
    return x % 2 == 0

x_evens = [x for x in xs if is_even(x)]    # список четных чисел = [2, 4]
x_evens = filter(is_even, xs)              # то же, что и выше
list_evener = partial(filter, is_even)     # функция, которая фильтрует список 
x_evens = list_evener(xs)     #снова [2, 4]

# Функция reduce выполняет свертку списка, т. е. объединяет первые два элемента,
# затем этот результат с третьим элементом, а тот с четвертым и т. д., возвращая
# единственный результат:
from functools import reduce
x_product = reduce(multiply, xs)            #  1*2*3*4 = 24
list_product = partial(reduce, multiply)    # функция, которая упрощает список
x_product = list_product(xs)                # снова = 24

#Функция enumerate
#Нередко нужно итеративно обойти список, используя как элементы, так и их индексы:
documents = [] # список неких документов; здесь он пустой
# не по-питоновски
for i in range(len(documents)):
    document = documents[i]
    do_something(i, document)
# тоже не по-питоновски
i = 0
for document in documents:
    do_something(i, document)
    i += 1
#Питоновским решением является встроенная функция enumerate, которая создает
#кортежи В формате (индекс, элемент):
for i, document in enumerate(documents):
    do_something(i, document)

#Точно так же, если нужны только индексы:
for i in range(len(documents)): do_something (i) # не по-питоновски
for i, _ in enumerate (documents) : do_something(i) # по-питоновски

#Функция zip и распаковка аргументов
#Часто возникает необходимость объединить два или более списков в один. Встроенная функция zip преобразует несколько списков в один список кортежей, состоящий из соответствующих элементов:
listl = ['a', 'b', 'c']
list2 = [1, 2, 3]
list (zip (listl, list2)) # [('a', 1), ('b', 2), ('c', 3) ]

# Если списки имеют разные длины, то функция прекратит работу, как только закончится первый из них. "Разъединить" список можно при помощи замысловатого трюка:
pairs = [('a', 1), ('b', 2), ('c', 3)] 
letters, numbers = zip(*pairs)
#Звездочка * выполняет распаковку аргументов, которая использует элементы пар
#в качестве индивидуальных аргументов для функции zip. Это то же самое, если вызвать:
list (zip (('a', 1), ('b', 2), ('c', 3)))
#Результат в обоих случаях будет [('а', 'Ь', 'с'), (1,2,3)].
#Распаковку аргументов можно применять с любой функцией:
def add (a, b): return a + b
add(1, 2) # вернет 3
add([1, 2]) # ошибка TypeError!
add(*[1, 2]) # вернет 3

#Переменные args и kwargs
#Предположим, нужно создать функцию высшего порядка, которая в качестве входящего аргумента принимает некую функцию f и возвращает новую функцию, которая для любого входящего аргумента возвращает удвоенное значение f:
# удвоитель
def doubler(f):
    def g(x):
        return 2 * f(x)
    return g

def f1(x):
    return x + 1

g = doubler(f1)
print(g(3))  # 8 или (3+1)*2
print(g(-1)) # 0 или (-1 + 1)*2
#Но терпит неудачу с функциями, которые принимают более одного аргумента:
def f2(x, y):
    return x + y
g = doubler(f2)
print(g(1, 2)) # TypeError: g() принимает ровно 1 аргумент (задано 2)

# Хотелось бы определить функцию, которая принимает произвольное количество
# аргументов. Это делается при помощи распаковки аргументов и небольшого волшебства:
def magic(*args, **kwargs):
    print("безымянные аргументы:", args)
    print("аргументы по ключу:", kwargs)

magic(1, 2, key="word", key2="word2")

# напечатает безымянные аргументы: (1, 2)
# аргументы по ключу: {'кеу2': 'word2', 'key': 'word'}
#Другими словами, когда функция определена подобным образом, переменная args
#представляет собой кортеж из безымянных позиционных аргументов, а переменная
#kwargs— словарь из именованных аргументов. Она работает и по-другому, если
#нужно воспользоваться списком (или кортежем) и словарем для того, чтобы передать аргументы в функцию:

def other_way_magic(x, y, z):
    return x + y + z

x_y_list = [1, 2]
z_dict = { "z" : 3 }
print(other_way_magic(*x_y_list, **z_dict)) # 6

#Эти свойства переменных args и kwargs позволяют проделывать разного рода замысловатые трюки. Здесь этот прием будет использоваться исключительно для создания функций высшего порядка, которые могут принимать произвольное число входящих аргументов:
# корректный удвоитель
def doubler_correct(f):
    """работает независимо от того, какого рода аргументы
    функция f ожидает"""

    def g(*args, **kwargs):
        """какими бы ни были аргументы для д, передать их в f"""
        return 2 * f(*args, **kwargs)
    return g
g = doubler_correct(f2)
print(g(1, 2)) # 6


