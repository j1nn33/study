########## Сортировка
# Каждый список в Python располагает методом sort (), который упорядочивает его на
# месте, т. е. внутри списка без выделения дополнительной памяти. Чтобы избежать
# изменений в списке, можно применить встроенную функцию sorted, которая возвращает новый список:
x = [4,1,2,3]
y = sorted(x)   # после сортировки = [1, 2, 3, 4], х не изменился
x.sort()        # теперь х = [1, 2, 3, 4]
# вместо сравнения самих элементов можно сравнивать результаты функции, которую надо указать
#вместе с ключом key:
# сортировать список по абсолютному значению в убывающем порядке
x = sorted([-4,1,-2,3], key=abs, reverse=True) # = [-4,3,-2,1]
# сортировать слова и их частотности по убывающему значению частот
word_counts = [('a', 1), ('b', 2)]
wc = sorted(word_counts.items(), key=lambda word, count: count, reverse=True)

########## Генераторы последовательностей
# необходимость преобразовать некий список в другой, выбирая
# только определенные элементы или внося по ходу изменения в элементы исходного
# списка, или выполняя и то и другое одновременно. Питоновским решением является применение генераторов последовательностей (еще именуемых списковыми
# включениями)

# четные числа
even_numbers = [x for x in range(5) if x % 2 == 0] # [0, 2, 4]
# квадраты чисел
squares = [x * x for x in range(5)] # [0, 1, 4, 9, 16]
# квадраты четных чисел 
even_squares = [x * x for x in even_numbers] # [0, 4, 16]

# словарь с квадратами чисел
square_dict = { x : x * x for x in range(5) } # { 0:0, 1:1, 2:4, 3:9, 4:16 }
# множество с квадратами чисел
square_set = { x * x for x in [1, -1] } # { 1 }

# Если значение в списке не нужно, то обычно в качестве переменной используется символ подчеркивания:
# нули
zeroes = [0 for _ in even_numbers] # имеет ту же длину, что и even_numbers

# пары
pairs = [(x, y)
    for x in range(10)
    for y in range(10)]       # 100 nap (0,0) (0,1)... (9,8), (9,9)
# И последующие операторы for могут использовать результаты предыдущих:
# пары с возрастающим значением
increasing_pairs = [(x, y)     # только пары с х < у,
    for x in range(10)         # range (мин, макс) равен
    for y in range(x + 1, 10)] # [мин, мин+1, ..., макс-1]

########## Функции-генераторы и генераторные выражения
# Проблема со списками заключается в том, что они легко вырастают до больших
# размеров. Выражение range (1ООООО) создает фактическую последовательность
# Если их обрабатывать по одному за итерацию цикла, то они могут стать главной причиной неэффективности (или нехватки оперативной памяти). А если потенциально будут использоваться лишь первые несколько значений, то вычисление всех элементов становится пустой тратой ресурсов.
# Генератор — это объект, который можно последовательно перебрать (обычно при
# помощи оператора for), но чьи значения предоставляются только тогда, когда онитребуются (используя ленивое вычисление).

# Первый способ создания генераторов заключается в использовании функции генератора совместно с оператором yield:
def lazy_range(n):
    """ленивая версия последовательности range"""
    i = 0
    while i < n:
        yield i
        i += 1
# Представленный далее цикл будет потреблять предоставляемые значения по одному за итерацию, пока элементы не закончатся:
def do_something_with(i):
    pass
    return

for i in lazy_range(10): do_something_with(i)

# (На самом деле Python уже располагает функцией iazy_range под названием xrange, а
# версии Python 3 сама последовательность (диапазон range) уже "ленивая”.) Такая
# функциональность позволяет задавать бесконечную последовательность:
"""
Обратной стороной ленивого вычисления является то, что просмотр генератора
можно выполнить всего один раз. Если нужно просмотреть многократно, то следует
либо каждый раз создавать генератор заново, либо использовать список
"""
#Второй способ создания генераторов — использовать генераторное выражение, т. е.
#генератор последовательности с оператором for, обрамленный круглыми скобками:
# ленивый список четных чисел меньше 20
lazy_evens_below_20 = (i for i in lazy_range(20) if i % 2 == 0)
#Следует отметить, что каждый объект diet имеет метод items (), который возвращает список пар "ключ-значение". Однако чаще будет применяться метод iteritemsO,
#который "лениво" предоставляет по одной паре по мере навигации по словарю;
##########
# Случайные числа


##########
##########
##########
